#include <BMP280_DEV.h>
#include <Device.h>
#include <Wire.h>
#include <Servo.h>
#include <MPU9250.h>
#include <math.h>
#include <Arduino.h>
#include <VL53L0X.h>

float Kp = 0.04, Kd = 0.9, Ki = 0.03;
int pid_max_yaw = 180, pid_max_pitch = 180, pid_max_roll = 80; //maximum output = degrees/s maximum range
float iError_yaw, dError_yaw, previouspError_yaw;
float  previouspError_pitch;
float dError_roll, previouspError_roll;
float pid_i_yaw = Ki, pid_i_pitch = Ki, pid_i_roll = Ki; //store integral calculations to monitor windup
int previous_pid_output_yaw, previous_pid_output_pitch, previous_pid_output_roll;
float pid_input_yaw, pid_input_pitch, pid_input_roll;
float pid_output_yaw, pid_output_pitch, pid_output_roll;
float pid_setpoint_yaw = 0, pid_setpoint_pitch = 0, pid_setpoint_roll = 0;
float pid_p_gain_pitch = Kp, pid_i_gain_pitch = Ki, pid_d_gain_pitch = Kd;
float pid_p_gain_roll = Kp, pid_i_gain_roll = Ki, pid_d_gain_roll = Kd;
float pid_p_gain_yaw = Kp, pid_i_gain_yaw = Ki, pid_d_gain_yaw = Kd;
float pError_yaw, iError_pitch, pError_pitch, dError_pitch, iError_roll, pError_roll;

const int numReadingsr = 10, numReadingsp = 10, numReadingsy = 10;
int readingsr[numReadingsr], readingsp[numReadingsp], readingsy[numReadingsy];
int readIndexr = 0, readIndexp = 0, readIndexy = 0;
int totalr = 0, totalp = 0, totaly = 0;
int averager = 0, averagep = 0, averagey = 0;

int PWM_roll, PWM_yaw, PWM_pitch, PWM_thrust = 10;
int pwmmax = 255, pwmmin = 0;

int PIN_1 = 2, PIN_2 = 3, PIN_3 = 4, PIN_4 = 5;
int ledPin = 23;
float PID_roll, PID_yaw, PID_pitch, PID_alt;
float temperature, pressure, altitudbar;
int altitudlaser, ONOFF = 1, resetpid = 1;;

Servo ESC1, ESC2, ESC3, ESC4;  // create servo object to control the ESC

BMP280_DEV bmp280;
MPU9250 mpu;
VL53L0X laseralt;

void setup()
{
  Serial.begin(9600);
  Wire.begin();

  pinMode(ledPin, OUTPUT);
  digitalWrite(ledPin, HIGH);

  laseralt.setTimeout(500);
  if (!laseralt.init())
  {
    Serial.println("Failed to detect and initialize sensor!");
    while (1) {}
  }
  laseralt.startContinuous(20);

  bmp280.begin(0X76);
  bmp280.setTimeStandby(TIME_STANDBY_1000MS);
  bmp280.startNormalConversion();
  mpu.setup();

  erstellenpwm();

  mpu.update();
  bmp280.getMeasurements(temperature, pressure, altitudbar);

  delay(2000);

  for (int thisReading = 0; thisReading < numReadingsr; thisReading++) {
    readingsr[thisReading] = 0;
  }
  for (int thisReading = 0; thisReading < numReadingsp; thisReading++) {
    readingsp[thisReading] = 0;
  }
  for (int thisReading = 0; thisReading < numReadingsy; thisReading++) {
    readingsy[thisReading] = 0;
  }

  ledblink();
}

void loop()
{
  if (ONOFF == 1)
  {
    digitalWrite(ledPin, HIGH);
    rollpitchyaw();
    altitud();
    PIDE();
  }

  if (ONOFF == 0)
  {
    digitalWrite(ledPin, LOW);
    ESC1.write(pwmmin);
    ESC2.write(pwmmin);
    ESC3.write(pwmmin);
    ESC4.write(pwmmin);
  }
}

void rollpitchyaw()
{
  static uint32_t prev_ms = millis();
  if ((millis() - prev_ms) > 16)
  {
    mpu.update();

    totalp = totalp - readingsp[readIndexp];
    readingsp[readIndexp] =  mpu.getRoll();
    totalp = totalp + readingsp[readIndexp];
    readIndexp = readIndexp + 1;
    if (readIndexp >= numReadingsp) {
      readIndexp = 0;
    }
    averagep = totalp / numReadingsp;
    pid_input_pitch = averagep;

    totaly = totaly - readingsy[readIndexy];
    readingsy[readIndexy] = mpu.getYaw();
    totaly = totaly + readingsy[readIndexy];
    readIndexy = readIndexy + 1;
    if (readIndexy >= numReadingsy) {
      readIndexy = 0;
    }
    averagey = totaly / numReadingsy;
    pid_input_yaw = averagey;

    totalr = totalr - readingsr[readIndexr];
    readingsr[readIndexr] = mpu.getPitch();
    totalr = totalr + readingsr[readIndexr];
    readIndexr = readIndexr + 1;
    if (readIndexr >= numReadingsr) {
      readIndexr = 0;
    }
    averager = totalr / numReadingsr;
    pid_input_roll = averager;

    prev_ms = millis();
  }
}

void erstellenpwm()
{
  ESC1.attach(PIN_1, pwmmin, pwmmax); //CW 1
  ESC2.attach(PIN_2, pwmmin, pwmmax); //CW 3
  ESC3.attach(PIN_3, pwmmin, pwmmax); //CCW 2
  ESC4.attach(PIN_4, pwmmin, pwmmax); //CCW 4

  delay(7000);
  ESC1.write(pwmmax);
  ESC2.write(pwmmax);
  ESC3.write(pwmmax);
  ESC4.write(pwmmax);

  delay(3000);
  ESC1.write(pwmmin);
  ESC2.write(pwmmin);
  ESC3.write(pwmmin);
  ESC4.write(pwmmin);

  ledblink();
}

void altitud()
{
  bmp280.getMeasurements(temperature, pressure, altitudbar);
  altitudlaser = laseralt.readRangeContinuousMillimeters();
}

void ledblink()
{
  delay(125);
  digitalWrite(ledPin, LOW);
  delay(125);
  digitalWrite(ledPin, HIGH);
  delay(125);
  digitalWrite(ledPin, LOW);
  delay(125);
  digitalWrite(ledPin, HIGH);
  delay(125);
  digitalWrite(ledPin, LOW);
  delay(125);
  digitalWrite(ledPin, HIGH);
  delay(125);
  digitalWrite(ledPin, LOW);
  delay(125);
  digitalWrite(ledPin, HIGH);
}

void PIDE()
{
  if (resetpid == 1)
  {
    pError_yaw = 0; pError_pitch = 0; pError_roll = 0;
    iError_yaw = 0; iError_pitch = 0; iError_roll = 0;
    dError_yaw = 0; dError_pitch = 0; dError_roll = 0;
    pid_i_yaw = 0; pid_i_pitch = 0; pid_i_roll = 0;
    pid_output_yaw = 0;
    pid_output_pitch = 0;
    pid_output_roll = 0;
    resetpid = 0;
  }

  //YAW
  pError_yaw = pid_input_yaw - pid_setpoint_yaw; //Looks at the input, compare it to where you want it to be
  iError_yaw += pError_yaw; // Looks at the pError qnd compares how long it has been that way
  pid_i_yaw = pid_i_gain_yaw * iError_yaw; //Integral Calculations
  if (pid_i_yaw > pid_max_yaw) pid_i_yaw = pid_max_yaw; //prevent integral windup by limiting the integral to the max yaw
  else if (pid_i_yaw < pid_max_yaw * -1) pid_i_yaw = pid_max_yaw * -1;
  dError_yaw = (pError_yaw - previouspError_yaw);

  pid_output_yaw = (pid_p_gain_yaw * pError_yaw) + pid_i_yaw + (pid_d_gain_yaw * dError_yaw); //Output calculation
  if (pid_output_yaw > pid_max_yaw) pid_output_yaw = pid_max_yaw;
  else if (pid_output_yaw < pid_max_yaw * -1) pid_output_yaw = pid_max_yaw * -1;

  //PITCH
  pError_pitch = pid_input_pitch - pid_setpoint_pitch; //Looks at the input, compare it to where you want it to be
  iError_pitch += pError_pitch; // Looks at the pError qnd compares how long it has been that way
  pid_i_pitch = pid_i_gain_pitch * iError_pitch; //integral calculations
  if (pid_i_pitch > pid_max_pitch) pid_i_pitch = pid_max_pitch; //prevent integral windup by limiting the integral to the max pitch
  else if (pid_i_pitch < pid_max_pitch * -1) pid_i_pitch = pid_max_pitch * -1;
  dError_pitch = (pError_pitch - previouspError_pitch);

  pid_output_pitch = (pid_p_gain_pitch * pError_pitch) + pid_i_pitch + (pid_d_gain_pitch * dError_pitch) ; //Output calculation
  if (pid_output_pitch > pid_max_pitch) pid_output_pitch = pid_max_pitch;
  else if (pid_output_pitch < pid_max_pitch * -1) pid_output_pitch = pid_max_pitch * -1;

  //ROLL
  pError_roll = pid_input_roll - pid_setpoint_roll; //Looks at the input, compare it to where you want it to be
  iError_roll += pError_roll; // Looks at the pError qnd compares how long it has been that way
  pid_i_roll = pid_i_gain_roll * iError_roll;
  if (pid_i_roll > pid_max_roll) pid_i_roll = pid_max_roll; //prevent integral windup by limiting the integral to the maximum roll
  else if (pid_i_roll < pid_max_roll * -1) pid_i_roll = pid_max_roll * -1;
  dError_roll = (pError_roll - previouspError_roll);

  pid_output_roll = (pid_p_gain_roll * pError_roll) + pid_i_roll + (pid_d_gain_roll * dError_roll); //Output calculation
  if (pid_output_roll > pid_max_roll) pid_output_roll = pid_max_roll;
  else if (pid_output_roll < pid_max_roll * -1) pid_output_roll = pid_max_roll * -1;


  //Remember previous values
  previouspError_yaw = pError_yaw;
  previouspError_pitch = pError_pitch;
  previouspError_roll = pError_roll;
  previous_pid_output_yaw = pid_output_yaw;
  previous_pid_output_pitch = pid_output_pitch;
  previous_pid_output_roll = pid_output_roll;

  Serial.print("ipitch ");
  Serial.print(pid_input_pitch);
  Serial.print("//iroll ");
  Serial.print(pid_input_roll);
  Serial.print("//iyaw ");
  Serial.print(pid_input_yaw);

  Serial.print("\\oroll ");
  Serial.print(previous_pid_output_roll);
  Serial.print("\\opitch ");
  Serial.print(previous_pid_output_pitch);
  Serial.print("\\oyaw ");
  Serial.print(previous_pid_output_yaw);
  
  Serial.println(" ");
}
