#include <Wire.h>
#include <Servo.h>
#include <BMP280_DEV.h>
#include <Device.h>
#include <MPU9250.h>
#include <math.h>
#include <VL53L0X.h>

Servo L_F_prop;
Servo L_B_prop;
Servo R_F_prop;
Servo R_B_prop;

MPU9250 mpu;
BMP280_DEV bmp280;
VL53L0X laseralt;

float temperature, pressure, altitudbar;
int ledPin = 23, altitudlaser;

//To store the 1000us to 2000us value we create variables and store each channel
int input_YAW;      //In my case channel 4 of the receiver and pin D12 of arduino
int input_PITCH = 0;  //In my case channel 2 of the receiver and pin D9 of arduino
int input_ROLL = 0;   //In my case channel 1 of the receiver and pin D8 of arduino
int input_THROTTLE = 1200; //In my case channel 3 of the receiver and pin D10 of arduino

//Gyro Variables
float elapsedTime, time, timePrev;        //Variables for time control
int gyro_error = 0;                       //We use this variable to only calculate once the gyro data error
float Gyr_rawX, Gyr_rawY, Gyr_rawZ;       //Here we store the raw data read
float Gyro_angle_x, Gyro_angle_y;         //Here we store the angle value obtained with Gyro data
float Gyro_raw_error_x, Gyro_raw_error_y; //Here we store the initial gyro data error

//Acc Variables
int acc_error = 0;                          //We use this variable to only calculate once the Acc data error
float rad_to_deg = 180 / 3.141592654;       //This value is for pasing from radians to degrees values
float Acc_rawX, Acc_rawY, Acc_rawZ;         //Here we store the raw data read
float Acc_angle_x, Acc_angle_y;             //Here we store the angle value obtained with Acc data
float Acc_angle_error_x, Acc_angle_error_y; //Here we store the initial Acc data error
float Total_angle_x, Total_angle_y;

///////////////////////////////ROLL PID CONSTANTS////////////////////
double roll_kp = 0.057; //3.55
double roll_ki = 0.03; //0.003
double roll_kd = 0.01; //2.05
float roll_desired_angle = 0;
///////////////////////////////PITCH PID CONSTANTS///////////////////
double pitch_kp = 0.057; //3.55
double pitch_ki = 0.003; //0.003
double pitch_kd = 0.01; //2.05
float pitch_desired_angle = 0;
//////////////////////////////PID FOR PITCH//////////////////////////
float pitch_PID, pitch_error, pitch_previous_error;
float pitch_pid_p;
float pitch_pid_i;
float pitch_pid_d;
//////////////////////////////PID FOR ROLL///////////////////////////
float roll_PID, pwm_L_F, pwm_L_B, pwm_R_F, pwm_R_B, roll_error, roll_previous_error;
float roll_pid_p;
float roll_pid_i;
float roll_pid_d;

const int numReadingsr = 10, numReadingsp = 10, numReadingsy = 10;
int readingsr[numReadingsr], readingsp[numReadingsp], readingsy[numReadingsy];
int readIndexr = 0, readIndexp = 0, readIndexy = 0;
int totalr = 0, totalp = 0, totaly = 0;
int averager = 0, averagep = 0, averagey = 0;

void setup() {
  Wire.begin();
  pinMode(ledPin, OUTPUT);
  Serial.begin(9600);
  laseralt.setTimeout(500);
  if (!laseralt.init())
  {
    Serial.println("Failed to detect and initialize sensor!");
    while (1) {}
  }
  laseralt.startContinuous(20);
  bmp280.begin(0X76);
  bmp280.setTimeStandby(TIME_STANDBY_1000MS);
  bmp280.startNormalConversion();
  mpu.setup();
  L_F_prop.attach(2, 1000, 2000);
  R_F_prop.attach(3, 1000, 2000);
  R_B_prop.attach(4, 1000, 2000);
  L_B_prop.attach(5, 1000, 2000);
  delay(7000);
  L_F_prop.write(2000);
  R_F_prop.write(2000);
  R_B_prop.write(2000);
  L_B_prop.write(2000);
  delay(3000);
  L_F_prop.write(1000);
  R_F_prop.write(1000);
  R_B_prop.write(1000);
  L_B_prop.write(1000);
  Wire.begin();
  Wire.beginTransmission(0x68);
  Wire.write(0x6B);
  Wire.write(0x00);
  Wire.endTransmission(true);
  Wire.beginTransmission(0x68);
  Wire.write(0x1B);
  Wire.write(0x10);
  Wire.endTransmission(true);
  Wire.beginTransmission(0x68);
  Wire.write(0x1C);
  Wire.write(0x10);
  Wire.endTransmission(true);
  delay(1000);
  time = millis();
  if (gyro_error == 0)
  {
    for (int i = 0; i < 200; i++)
    {
      Wire.beginTransmission(0x68);
      Wire.write(0x43);
      Wire.endTransmission(false);
      Wire.requestFrom(0x68, 4, true);
      Gyr_rawX = Wire.read() << 8 | Wire.read();
      Gyr_rawY = Wire.read() << 8 | Wire.read();
      Gyro_raw_error_x = Gyro_raw_error_x + (Gyr_rawX / 32.8);
      Gyro_raw_error_y = Gyro_raw_error_y + (Gyr_rawY / 32.8);
      if (i == 199)
      {
        Gyro_raw_error_x = Gyro_raw_error_x / 200;
        Gyro_raw_error_y = Gyro_raw_error_y / 200;
        gyro_error = 1;
      }
    }
  }
  if (acc_error == 0)
  {
    for (int a = 0; a < 200; a++)
    {
      Wire.beginTransmission(0x68);
      Wire.write(0x3B);
      Wire.endTransmission(false);
      Wire.requestFrom(0x68, 6, true);
      Acc_rawX = (Wire.read() << 8 | Wire.read()) / 4096.0 ; //each value needs two registres
      Acc_rawY = (Wire.read() << 8 | Wire.read()) / 4096.0 ;
      Acc_rawZ = (Wire.read() << 8 | Wire.read()) / 4096.0 ;
      Acc_angle_error_x = Acc_angle_error_x + ((atan((Acc_rawY) / sqrt(pow((Acc_rawX), 2) + pow((Acc_rawZ), 2))) * rad_to_deg));
      Acc_angle_error_y = Acc_angle_error_y + ((atan(-1 * (Acc_rawX) / sqrt(pow((Acc_rawY), 2) + pow((Acc_rawZ), 2))) * rad_to_deg));
      if (a == 199)
      {
        Acc_angle_error_x = Acc_angle_error_x / 200;
        Acc_angle_error_y = Acc_angle_error_y / 200;
        acc_error = 1;
      }
    }
  }
  mpu.update();
  bmp280.getMeasurements(temperature, pressure, altitudbar);
  for (int thisReading = 0; thisReading < numReadingsr; thisReading++) {
    readingsr[thisReading] = 0;
  }
  for (int thisReading = 0; thisReading < numReadingsp; thisReading++) {
    readingsp[thisReading] = 0;
  }
  for (int thisReading = 0; thisReading < numReadingsy; thisReading++) {
    readingsy[thisReading] = 0;
  }
  delay(2000);
  ledblink();
}

void loop() {
  timePrev = time;
  time = millis();
  elapsedTime = (time - timePrev) / 1000;
  altitud();
  Wire.beginTransmission(0x68);
  Wire.write(0x43);
  Wire.endTransmission(false);
  Wire.requestFrom(0x68, 4, true);
  Gyr_rawX = Wire.read() << 8 | Wire.read();
  Gyr_rawY = Wire.read() << 8 | Wire.read();
  Gyr_rawX = (Gyr_rawX / 32.8) - Gyro_raw_error_x;
  Gyr_rawY = (Gyr_rawY / 32.8) - Gyro_raw_error_y;
  Gyro_angle_x = Gyr_rawX * elapsedTime;
  Gyro_angle_y = Gyr_rawY * elapsedTime;
  Wire.beginTransmission(0x68);
  Wire.write(0x3B);
  Wire.endTransmission(false);
  Wire.requestFrom(0x68, 6, true);
  Acc_rawX = (Wire.read() << 8 | Wire.read()) / 4096.0 ; //each value needs two registres
  Acc_rawY = (Wire.read() << 8 | Wire.read()) / 4096.0 ;
  Acc_rawZ = (Wire.read() << 8 | Wire.read()) / 4096.0 ;
  Acc_angle_x = (atan((Acc_rawY) / sqrt(pow((Acc_rawX), 2) + pow((Acc_rawZ), 2))) * rad_to_deg) - Acc_angle_error_x;
  Acc_angle_y = (atan(-1 * (Acc_rawX) / sqrt(pow((Acc_rawY), 2) + pow((Acc_rawZ), 2))) * rad_to_deg) - Acc_angle_error_y;
  Total_angle_x = 0.98 * (Total_angle_x + Gyro_angle_x) + 0.02 * Acc_angle_x;
  Total_angle_y = 0.98 * (Total_angle_y + Gyro_angle_y) + 0.02 * Acc_angle_y;
  roll_desired_angle = 0;
  pitch_desired_angle = 0;

  //    Serial.print("roll_desired_angle: ");
  //    Serial.print(roll_desired_angle);
  //    Serial.print("   |   ");
  //    Serial.print("pitch_desired_angle: ");
  //    Serial.print(pitch_desired_angle);
  //    Serial.print("   |   ");

  roll_error =  Total_angle_y - roll_desired_angle;
  pitch_error =  Total_angle_x - pitch_desired_angle;

  //  Serial.print("roll_error: ");
  //  Serial.print(roll_error);
  //  Serial.print("   |   ");
  //  Serial.print("pitch_error: ");
  //  Serial.print(pitch_error);
  //  Serial.print("   |   ");

  roll_pid_p = roll_kp * roll_error;
  pitch_pid_p = pitch_kp * pitch_error;

  //  Serial.print("roll_pid_p: ");
  //  Serial.print(roll_pid_p);
  //  Serial.print("   |   ");
  //  Serial.print("pitch_pid_p: ");
  //  Serial.print(pitch_pid_p);

  if (-3 < roll_error < 3)
  {
    roll_pid_i = roll_pid_i + (roll_ki * roll_error);
  }
  if (-3 < pitch_error < 3)
  {
    pitch_pid_i = pitch_pid_i + (pitch_ki * pitch_error);
  }

  //  Serial.print("   |   ");
  //  Serial.print("roll_pid_i: ");
  //  Serial.print(roll_pid_i);
  //  Serial.print("   |   ");
  //  Serial.print("pitch_pid_i: ");
  //  Serial.print(pitch_pid_i);

  roll_pid_d = roll_kd * ((roll_error - roll_previous_error) / elapsedTime);
  pitch_pid_d = pitch_kd * ((pitch_error - pitch_previous_error) / elapsedTime);

  //  Serial.print("   |   ");
  //  Serial.print("roll_pid_d: ");
  //  Serial.print(roll_pid_d);
  //  Serial.print("   |   ");
  //  Serial.print("pitch_pid_d: ");
  //  Serial.print(pitch_pid_d);

  roll_PID = roll_pid_p + roll_pid_i + roll_pid_d;
  pitch_PID = pitch_pid_p + pitch_pid_i + pitch_pid_d;

  //  Serial.print("   |   ");
  //  Serial.print("roll_PID: ");
  //  Serial.print(roll_PID);
  //  Serial.print("   |   ");
  //  Serial.print("pitch_PID: ");
  //  Serial.print(pitch_PID);

  if (roll_PID < -400) {
    roll_PID = -400;
  }
  if (roll_PID > 400) {
    roll_PID = 400;
  }
  if (pitch_PID < -4000) {
    pitch_PID = -400;
  }
  if (pitch_PID > 400) {
    pitch_PID = 400;
  }

  input_THROTTLE = altitudlaser;

  //input_THROTTLE = 1100;

  Serial.print("input_THROTTLE: ");
  Serial.print(input_THROTTLE);
  Serial.print("   |   ");

  pwm_L_B  = input_THROTTLE - roll_PID - pitch_PID;
  pwm_L_F  = input_THROTTLE - roll_PID + pitch_PID;
  pwm_R_F  = input_THROTTLE + roll_PID + pitch_PID;
  pwm_R_B  = input_THROTTLE + roll_PID - pitch_PID;

  //  if (pwm_R_F < 1100)
  //  {
  //    pwm_R_F = 1100;
  //  }
  //  if (pwm_R_F > 2000)
  //  {
  //    pwm_R_F = 2000;
  //  }
  //
  //  if (pwm_L_F < 1100)
  //  {
  //    pwm_L_F = 1100;
  //  }
  //  if (pwm_L_F > 2000)
  //  {
  //    pwm_L_F = 2000;
  //  }
  //
  //  if (pwm_R_B < 1100)
  //  {
  //    pwm_R_B = 1100;
  //  }
  //  if (pwm_R_B > 2000)
  //  {
  //    pwm_R_B = 2000;
  //  }
  //
  //  if (pwm_L_B < 1100)
  //  {
  //    pwm_L_B = 1100;
  //  }
  //  if (pwm_L_B > 2000)
  //  {
  //    pwm_L_B = 2000;
  //  }

  roll_previous_error = roll_error;
  pitch_previous_error = pitch_error;

  Serial.print("LB: ");
  Serial.print(pwm_L_B);
  Serial.print("   |   ");
  Serial.print("LF: ");
  Serial.print(pwm_L_F);
  Serial.print("   |   ");
  Serial.print("RF: ");
  Serial.print(pwm_R_F);
  Serial.print("   |   ");
  Serial.print("RB: ");
  Serial.print(pwm_R_B);

  Serial.print("   |   ");
  Serial.print("Xº: ");
  Serial.print(Total_angle_y);
  Serial.print("   |   ");
  Serial.print("Yº: ");
  Serial.print(Total_angle_x);
  Serial.println(" ");

  if (input_THROTTLE <= 800)
  {
    L_F_prop.writeMicroseconds(1000);
    L_B_prop.writeMicroseconds(1000);
    R_F_prop.writeMicroseconds(1000);
    R_B_prop.writeMicroseconds(1000);

    pwm_L_F = 1000;
    pwm_L_B = 1000;
    pwm_R_F = 1000;
    pwm_R_B = 1000;
  }
  else
  {
    L_F_prop.writeMicroseconds(pwm_L_F);
    L_B_prop.writeMicroseconds(pwm_L_B);
    R_F_prop.writeMicroseconds(pwm_R_F);
    R_B_prop.writeMicroseconds(pwm_R_B);
  }

}

void ledblink()
{
  delay(125);
  digitalWrite(ledPin, LOW);
  delay(125);
  digitalWrite(ledPin, HIGH);
  delay(125);
  digitalWrite(ledPin, LOW);
  delay(125);
  digitalWrite(ledPin, HIGH);
  delay(125);
  digitalWrite(ledPin, LOW);
  delay(125);
  digitalWrite(ledPin, HIGH);
  delay(125);
  digitalWrite(ledPin, LOW);
  delay(125);
  digitalWrite(ledPin, HIGH);
}

void altitud()
{
  bmp280.getMeasurements(temperature, pressure, altitudbar);

  totalp = totalp - readingsp[readIndexp];
  readingsp[readIndexp] =  laseralt.readRangeContinuousMillimeters();
  totalp = totalp + readingsp[readIndexp];
  readIndexp = readIndexp + 1;
  if (readIndexp >= numReadingsp) {
    readIndexp = 0;
  }
  averagep = totalp / numReadingsp;
  altitudlaser = averagep;
}
